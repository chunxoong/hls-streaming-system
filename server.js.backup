// HLS4U Stream Server - Production Redis Version
// Robust Redis implementation with fallback

require('dotenv').config();
const express = require('express');
const session = require('express-session');
const mysql = require('mysql2/promise');
const path = require('path');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');

const app = express();
const PORT = process.env.PORT || 3000;

// Redis configuration with robust error handling
const initRedisStore = async () => {
  try {
    const RedisStore = require('connect-redis').default;
    const { createClient } = require('redis');
    
    // Enhanced Redis client configuration
    const redisClient = createClient({
      socket: {
        host: process.env.REDIS_HOST || 'localhost',
        port: process.env.REDIS_PORT || 6379,
        connectTimeout: 10000,
        lazyConnect: true,
        reconnectStrategy: (retries) => {
          if (retries > 5) {
            console.log('âŒ Redis max retries exceeded');
            return new Error('Redis connection failed');
          }
          const delay = Math.min(retries * 50, 500);
          console.log(`ğŸ”„ Redis retry ${retries}, delay: ${delay}ms`);
          return delay;
        }
      },
      password: process.env.REDIS_PASSWORD || undefined,
      database: process.env.REDIS_DB || 0,
      retry_delay_on_failover: 100,
      max_attempts: 5
    });

    // Redis event handlers
    redisClient.on('connect', () => {
      console.log('ğŸ”Œ Redis connecting...');
    });

    redisClient.on('ready', () => {
      console.log('âœ… Redis connected and ready');
    });

    redisClient.on('error', (err) => {
      console.error('âŒ Redis error:', err.message);
    });

    redisClient.on('end', () => {
      console.log('ğŸ”Œ Redis connection ended');
    });

    redisClient.on('reconnecting', () => {
      console.log('ğŸ”„ Redis reconnecting...');
    });

    // Connect with timeout
    await Promise.race([
      redisClient.connect(),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Redis connection timeout')), 15000)
      )
    ]);

    // Test Redis connection
    await redisClient.ping();
    console.log('ğŸ“ Redis ping successful');

    // Create Redis store
    const store = new RedisStore({
      client: redisClient,
      prefix: 'hls4u:sess:',
      ttl: 86400, // 24 hours
      disableTouch: false,
      disableTTL: false
    });

    return { store, client: redisClient, connected: true };

  } catch (error) {
    console.error('âŒ Redis initialization failed:', error.message);
    return { store: null, client: null, connected: false };
  }
};

// Memory store fallback
const createMemoryStore = () => {
  console.log('âš ï¸  Using Memory Store fallback');
  return new session.MemoryStore();
};

// Database connection pool with enhanced configuration
const dbPool = mysql.createPool({
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 20,
  queueLimit: 0,
  acquireTimeout: 60000,
  timeout: 60000,
  enableKeepAlive: true,
  keepAliveInitialDelay: 0,
  idleTimeout: 300000, // 5 minutes
  maxIdle: 10,
  maxReusedConnections: 100
});

// Test database connection
const testDatabase = async () => {
  try {
    const connection = await dbPool.getConnection();
    await connection.ping();
    connection.release();
    console.log('âœ… Database connected successfully');
    return true;
  } catch (error) {
    console.error('âŒ Database connection failed:', error.message);
    return false;
  }
};

// Security middleware
app.use(helmet({
  contentSecurityPolicy: false,
  crossOriginEmbedderPolicy: false,
  hsts: process.env.NODE_ENV === 'production'
}));

// CORS configuration
app.use(cors({
  origin: function (origin, callback) {
    // Allow all origins for development, restrict in production
    if (process.env.NODE_ENV === 'production') {
      const allowedOrigins = (process.env.ALLOWED_ORIGINS || '').split(',');
      if (!origin || allowedOrigins.includes(origin)) {
        callback(null, true);
      } else {
        callback(new Error('Not allowed by CORS'));
      }
    } else {
      callback(null, true);
    }
  },
  credentials: true
}));

// Enhanced rate limiting
const createRateLimiter = (windowMs, max, message) => 
  rateLimit({
    windowMs,
    max,
    message,
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
      res.status(429).json({ error: message });
    }
  });

// Apply different rate limits
app.use('/api/', createRateLimiter(15 * 60 * 1000, 200, 'API rate limit exceeded'));
app.use('/admin/upload', createRateLimiter(60 * 60 * 1000, 20, 'Upload limit exceeded'));
app.use('/admin/login', createRateLimiter(15 * 60 * 1000, 5, 'Too many login attempts'));

// Body parser with large limits for uploads
app.use(express.json({ limit: '100mb' }));
app.use(express.urlencoded({ extended: true, limit: '100mb' }));

// Static files with optimized headers
app.use('/hls', express.static(path.join(__dirname, 'hls'), {
  maxAge: process.env.NODE_ENV === 'production' ? '1d' : 0,
  etag: true,
  lastModified: true,
  setHeaders: (res, filePath) => {
    if (filePath.endsWith('.m3u8')) {
      res.setHeader('Cache-Control', 'public, max-age=10');
      res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
    } else if (filePath.endsWith('.ts')) {
      res.setHeader('Cache-Control', 'public, max-age=2592000');
      res.setHeader('Content-Type', 'video/mp2t');
    }
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Range');
  }
}));

app.use('/public', express.static(path.join(__dirname, 'public'), {
  maxAge: process.env.NODE_ENV === 'production' ? '7d' : 0
}));

// View engine
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));
app.locals.db = dbPool;

// Global variables for session store
let sessionStore;
let redisClient;
let isRedisConnected = false;

// Enhanced health check
app.get('/health', async (req, res) => {
  const memUsage = process.memoryUsage();
  
  // Test Redis connection
  let redisStatus = 'disconnected';
  if (isRedisConnected && redisClient) {
    try {
      await redisClient.ping();
      redisStatus = 'connected';
    } catch (error) {
      redisStatus = 'error: ' + error.message;
    }
  }

  // Test DB connection
  let dbStatus = 'disconnected';
  try {
    const connection = await dbPool.getConnection();
    await connection.ping();
    connection.release();
    dbStatus = 'connected';
  } catch (error) {
    dbStatus = 'error: ' + error.message;
  }

  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    memory: {
      used: Math.round(memUsage.heapUsed / 1024 / 1024) + ' MB',
      total: Math.round(memUsage.heapTotal / 1024 / 1024) + ' MB',
      rss: Math.round(memUsage.rss / 1024 / 1024) + ' MB'
    },
    uptime: Math.round(process.uptime()) + 's',
    services: {
      redis: redisStatus,
      database: dbStatus,
      sessionStore: isRedisConnected ? 'redis' : 'memory'
    },
    dbPool: {
      total: dbPool.pool.config.connectionLimit,
      active: dbPool.pool.config.connectionLimit - dbPool.pool._freeConnections.length,
      free: dbPool.pool._freeConnections.length
    }
  });
});

// Routes
app.use('/', require('./app/routes/index'));
app.use('/api', require('./app/routes/api'));
app.use('/admin', require('./app/routes/admin'));
app.use('/upload', require('./app/routes/upload'));

// Enhanced error handling
app.use((err, req, res, next) => {
  console.error('Error:', err);
  
  // Handle specific error types
  if (err.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({ error: 'File too large' });
  }
  
  if (err.code === 'LIMIT_FILE_COUNT') {
    return res.status(413).json({ error: 'Too many files' });
  }
  
  if (err.message.includes('CORS')) {
    return res.status(403).json({ error: 'CORS policy violation' });
  }
  
  // Generic error
  res.status(500).json({ 
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal server error' 
      : err.message 
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).render('pages/404', { title: 'Page Not Found' });
});

// Graceful shutdown
const gracefulShutdown = async (signal) => {
  console.log(`\nğŸ“´ Received ${signal}, shutting down gracefully...`);
  
  try {
    // Close Redis connection
    if (redisClient && isRedisConnected) {
      await redisClient.quit();
      console.log('âœ… Redis connection closed');
    }
    
    // Close database pool
    await dbPool.end();
    console.log('âœ… Database pool closed');
    
    console.log('ğŸ‘‹ Goodbye!');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error during shutdown:', error);
    process.exit(1);
  }
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Uncaught exception handler
process.on('uncaughtException', (err) => {
  console.error('ğŸ’¥ Uncaught Exception:', err);
  gracefulShutdown('uncaughtException');
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('ğŸ’¥ Unhandled Rejection at:', promise, 'reason:', reason);
  gracefulShutdown('unhandledRejection');
});

// Start server with comprehensive initialization
const startServer = async () => {
  try {
    console.log('ğŸš€ Starting HLS4U Stream Server...\n');
    
    // Initialize Redis
    console.log('ğŸ“¦ Initializing Redis...');
    const redis = await initRedisStore();
    
    if (redis.connected) {
      sessionStore = redis.store;
      redisClient = redis.client;
      isRedisConnected = true;
      console.log('âœ… Redis store initialized');
    } else {
      sessionStore = createMemoryStore();
      isRedisConnected = false;
      console.log('âš ï¸  Fallback to Memory store');
    }
    
    // Test database
    console.log('ğŸ“¦ Testing database connection...');
    const dbConnected = await testDatabase();
    if (!dbConnected) {
      throw new Error('Database connection failed');
    }
    
    // Configure session middleware
    const sessionConfig = {
      store: sessionStore,
      secret: process.env.SESSION_SECRET || 'hls4u-secret-key-2024',
      resave: false,
      saveUninitialized: false,
      rolling: true,
      name: 'hls4u.sid',
      cookie: {
        secure: process.env.NODE_ENV === 'production' && process.env.HTTPS === 'true',
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000, // 24 hours
        sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax'
      }
    };
    
    app.use(session(sessionConfig));
    
    // Start HTTP server
    const server = app.listen(PORT, '127.0.0.1', () => {
      console.log('\nğŸ‰ Server started successfully!');
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log(`ğŸŒ Server: http://127.0.0.1:${PORT}`);
      console.log(`ğŸ“º Streaming: http://127.0.0.1:${PORT}/hls/`);
      console.log(`âš™ï¸  Admin: http://127.0.0.1:${PORT}/admin`);
      console.log(`ğŸ¥ Health: http://127.0.0.1:${PORT}/health`);
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log(`ğŸ’¾ Memory: ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)} MB`);
      console.log(`ğŸ—„ï¸  Session: ${isRedisConnected ? 'Redis' : 'Memory'} Store`);
      console.log(`ğŸ› Environment: ${process.env.NODE_ENV || 'development'}`);
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
    });
    
    // Handle server errors
    server.on('error', (err) => {
      if (err.code === 'EADDRINUSE') {
        console.error(`âŒ Port ${PORT} is already in use`);
      } else {
        console.error('âŒ Server error:', err);
      }
      process.exit(1);
    });
    
  } catch (error) {
    console.error('ğŸ’¥ Server startup failed:', error.message);
    process.exit(1);
  }
};

// Initialize server
startServer();

module.exports = app;